def create_backup(backup_dir="backups"):
    """
    Crea una copia de seguridad de la base de datos.

    Args:
        backup_dir: Directorio donde guardar backups

    Returns:
        dict con info del backup
    """
    import shutil

    # Create backup directory if not exists
    backup_path = Path(backup_dir)
    backup_path.mkdir(exist_ok=True)

    # Generate backup filename with timestamp
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    backup_filename = f"yukyu_backup_{timestamp}.db"
    backup_filepath = backup_path / backup_filename

    # Copy database file
    if not Path(DB_NAME).exists():
        raise ValueError(f"Database file {DB_NAME} not found")

    shutil.copy2(DB_NAME, backup_filepath)

    # Get backup file size
    file_size = backup_filepath.stat().st_size

    # Clean old backups (keep last 10)
    backups = sorted(backup_path.glob("yukyu_backup_*.db"), reverse=True)
    for old_backup in backups[10:]:
        old_backup.unlink()

    return {
        "filename": backup_filename,
        "path": str(backup_filepath),
        "size_bytes": file_size,
        "size_mb": round(file_size / (1024 * 1024), 2),
        "created_at": timestamp
    }


def list_backups(backup_dir="backups"):
    """
    Lista todos los backups disponibles.

    Returns:
        Lista de backups con info
    """
    backup_path = Path(backup_dir)

    if not backup_path.exists():
        return []

    backups = []
    for backup_file in sorted(backup_path.glob("yukyu_backup_*.db"), reverse=True):
        stat = backup_file.stat()
        backups.append({
            "filename": backup_file.name,
            "path": str(backup_file),
            "size_bytes": stat.st_size,
            "size_mb": round(stat.st_size / (1024 * 1024), 2),
            "created_at": datetime.fromtimestamp(stat.st_mtime).isoformat()
        })

    return backups


def restore_backup(backup_filename, backup_dir="backups"):
    """
    Restaura la base de datos desde un backup.
    CUIDADO: Esto sobrescribe la base de datos actual.

    Args:
        backup_filename: Nombre del archivo de backup
        backup_dir: Directorio de backups

    Returns:
        dict con info de la restauraci√≥n
    """
    import shutil

    backup_path = Path(backup_dir) / backup_filename

    if not backup_path.exists():
        raise ValueError(f"Backup file {backup_filename} not found")

    # Create a backup of current DB before restoring
    current_backup = create_backup(backup_dir)

    # Restore the backup
    shutil.copy2(backup_path, DB_NAME)

    return {
        "restored_from": backup_filename,
        "previous_backup": current_backup['filename'],
        "restored_at": datetime.now().isoformat()
    }


# ============================================
# AUDIT LOG FUNCTIONS (v2.3 - Complete Audit Trail)
# ============================================

