<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tests Integraci√≥n - Flujo UI Completo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            padding: 20px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        h1 {
            color: #00d4ff;
            margin-bottom: 10px;
        }
        .subtitle {
            color: #888;
            margin-bottom: 30px;
        }
        .summary {
            background: #1a1a1a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
            border-left: 4px solid #00d4ff;
        }
        .summary h2 {
            color: #00d4ff;
            margin-bottom: 15px;
            font-size: 18px;
        }
        .stats {
            display: flex;
            gap: 30px;
            font-size: 16px;
        }
        .stat {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
        }
        .pass { color: #34d399; }
        .fail { color: #f87171; }
        .test-result {
            background: #1a1a1a;
            padding: 15px 20px;
            margin-bottom: 10px;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-left: 4px solid transparent;
        }
        .test-result.passed {
            border-left-color: #34d399;
        }
        .test-result.failed {
            border-left-color: #f87171;
            background: #2a1a1a;
        }
        .test-name {
            flex: 1;
        }
        .test-status {
            font-weight: bold;
            font-size: 18px;
            margin-right: 10px;
        }
        .test-time {
            color: #888;
            font-size: 12px;
        }
        .error-details {
            margin-top: 10px;
            padding: 10px;
            background: #1a0a0a;
            border-radius: 4px;
            color: #ff8888;
            font-family: monospace;
            font-size: 12px;
        }
        .coverage {
            background: #1a1a1a;
            padding: 20px;
            border-radius: 8px;
            margin-top: 30px;
        }
        .coverage h2 {
            color: #00d4ff;
            margin-bottom: 15px;
        }
        .coverage-bar {
            height: 30px;
            background: #0a0a0a;
            border-radius: 15px;
            overflow: hidden;
            position: relative;
        }
        .coverage-fill {
            height: 100%;
            background: linear-gradient(90deg, #34d399, #00d4ff);
            transition: width 1s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #000;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîÑ Flujo UI Completo - Tests de Integraci√≥n</h1>
        <p class="subtitle">Tests del flujo completo de usuario: cargar datos ‚Üí filtrar ‚Üí visualizar</p>

        <div class="summary">
            <h2>Resumen de Ejecuci√≥n</h2>
            <div class="stats">
                <div class="stat">
                    <span>Total:</span>
                    <span class="stat-value" id="total-tests">0</span>
                </div>
                <div class="stat pass">
                    <span>‚úì Pasados:</span>
                    <span class="stat-value" id="passed-tests">0</span>
                </div>
                <div class="stat fail">
                    <span>‚úó Fallidos:</span>
                    <span class="stat-value" id="failed-tests">0</span>
                </div>
                <div class="stat">
                    <span>‚è±Ô∏è Tiempo:</span>
                    <span class="stat-value" id="total-time">0ms</span>
                </div>
            </div>
        </div>

        <div id="test-results"></div>

        <div class="coverage">
            <h2>Cobertura de Flujos</h2>
            <div class="coverage-bar">
                <div class="coverage-fill" id="coverage-bar" style="width: 0%">0%</div>
            </div>
        </div>
    </div>

    <script type="module">
        import { escapeHtml, safeNumber } from '../../static/js/modules/utils.js';
        import { ThemeManager } from '../../static/js/modules/theme-manager.js';
        import { DataService } from '../../static/js/modules/data-service.js';

        // Mock de fetch
        const originalFetch = window.fetch;

        function mockFetch(response) {
            window.fetch = async (url, options) => {
                return {
                    ok: response.ok !== false,
                    status: response.status || 200,
                    json: async () => response.data,
                    text: async () => response.text || JSON.stringify(response.data)
                };
            };
        }

        function restoreFetch() {
            window.fetch = originalFetch;
        }

        // Test Runner
        class UIFlowTestRunner {
            constructor() {
                this.tests = [];
                this.passed = 0;
                this.failed = 0;
                this.startTime = 0;
                this.totalFlows = 6;
                this.coveredFlows = new Set();
            }

            async test(name, fn) {
                const start = performance.now();
                const resultDiv = document.createElement('div');
                resultDiv.className = 'test-result';

                try {
                    await fn();
                    this.passed++;
                    resultDiv.classList.add('passed');
                    resultDiv.innerHTML = `
                        <span class="test-name">${name}</span>
                        <span class="test-status pass">‚úì</span>
                        <span class="test-time">${(performance.now() - start).toFixed(2)}ms</span>
                    `;
                    console.log('‚úì', name);
                } catch (e) {
                    this.failed++;
                    resultDiv.classList.add('failed');
                    resultDiv.innerHTML = `
                        <div>
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <span class="test-name">${name}</span>
                                <span class="test-status fail">‚úó</span>
                                <span class="test-time">${(performance.now() - start).toFixed(2)}ms</span>
                            </div>
                            <div class="error-details">${e.message}</div>
                        </div>
                    `;
                    console.error('‚úó', name, e);
                }

                document.getElementById('test-results').appendChild(resultDiv);
            }

            assert(condition, message) {
                if (!condition) {
                    throw new Error(message || 'Assertion failed');
                }
            }

            assertEqual(actual, expected, message) {
                if (actual !== expected) {
                    throw new Error(
                        message ||
                        `Expected "${expected}" but got "${actual}"`
                    );
                }
            }

            trackFlow(flowName) {
                this.coveredFlows.add(flowName);
            }

            finish() {
                const totalTime = performance.now() - this.startTime;
                const total = this.passed + this.failed;
                const coverage = (this.coveredFlows.size / this.totalFlows) * 100;

                document.getElementById('total-tests').textContent = total;
                document.getElementById('passed-tests').textContent = this.passed;
                document.getElementById('failed-tests').textContent = this.failed;
                document.getElementById('total-time').textContent = totalTime.toFixed(0) + 'ms';

                const coverageBar = document.getElementById('coverage-bar');
                setTimeout(() => {
                    coverageBar.style.width = coverage + '%';
                    coverageBar.textContent = coverage.toFixed(1) + '% flows';
                }, 100);

                console.log(`\nüìä Resumen: ${this.passed}/${total} tests pasados (${coverage.toFixed(1)}% flow coverage)`);
            }

            async run() {
                this.startTime = performance.now();
                await this.runTests();
                this.finish();
            }

            async runTests() {
                // ========== Flujo 1: Carga inicial de datos ==========
                await this.test('Flujo - Carga inicial de datos', async () => {
                    this.trackFlow('initial-load');

                    mockFetch({
                        data: [
                            { employee_num: '001', name: 'Áî∞‰∏≠Â§™ÈÉé', granted: 10, used: 5, year: 2024 },
                            { employee_num: '002', name: 'P√©rez Juan', granted: 12, used: 8, year: 2024 }
                        ],
                        available_years: [2023, 2024]
                    });

                    const state = { data: [], availableYears: [], year: null };
                    const ds = new DataService();

                    await ds.fetchEmployees(2024, true, state);

                    this.assertEqual(state.data.length, 2, 'Debe cargar 2 empleados');
                    this.assertEqual(state.availableYears.length, 2, 'Debe tener 2 a√±os');
                    this.assert(state.data[0].employeeNum === '001', 'Datos mapeados correctamente');

                    restoreFetch();
                });

                // ========== Flujo 2: Filtrado por a√±o ==========
                await this.test('Flujo - Filtrado por a√±o', async () => {
                    this.trackFlow('year-filter');

                    const ds = new DataService();
                    const allData = [
                        { year: 2023, name: 'A', used: 5 },
                        { year: 2024, name: 'B', used: 10 },
                        { year: 2024, name: 'C', used: 8 }
                    ];

                    // Filtrar 2024
                    const filtered = ds.getFiltered(allData, 2024);
                    this.assertEqual(filtered.length, 2, 'Debe filtrar solo 2024');

                    // Calcular stats sobre datos filtrados
                    const factoryData = [
                        { haken: 'Factory A', used: 10 },
                        { haken: 'Factory B', used: 5 }
                    ];
                    const stats = ds.getFactoryStats(factoryData);
                    this.assertEqual(stats.length, 2, 'Debe calcular stats');
                    this.assertEqual(stats[0][1], 10, 'Factory A debe tener 10');
                });

                // ========== Flujo 3: Validaci√≥n y escape de datos ==========
                await this.test('Flujo - Validaci√≥n y escape de datos peligrosos', async () => {
                    this.trackFlow('data-validation');

                    mockFetch({
                        data: [
                            {
                                employee_num: '001',
                                name: '<script>alert("XSS")</script>',
                                granted: 'abc', // Dato inv√°lido
                                used: '5'
                            }
                        ],
                        available_years: []
                    });

                    const state = { data: [] };
                    const ds = new DataService();

                    await ds.fetchEmployees(2024, true, state);

                    // Escapar nombre para mostrar en UI
                    const safeName = escapeHtml(state.data[0].name);
                    this.assert(!safeName.includes('<script>'), 'Nombre debe estar escapado');

                    // Validar n√∫meros
                    const granted = safeNumber(state.data[0].granted, 0);
                    this.assertEqual(granted, 0, 'Granted inv√°lido debe ser 0');

                    restoreFetch();
                });

                // ========== Flujo 4: Cambio de tema durante sesi√≥n ==========
                await this.test('Flujo - Cambio de tema durante sesi√≥n activa', async () => {
                    this.trackFlow('theme-change');

                    localStorage.removeItem('yukyu-theme');

                    // Iniciar sesi√≥n
                    const tm = new ThemeManager();
                    tm.init();
                    const initialTheme = tm.current;

                    // Usuario cambia tema
                    tm.toggle();
                    const newTheme = tm.current;

                    this.assert(initialTheme !== newTheme, 'Tema debe cambiar');

                    // Verificar persistencia
                    const saved = localStorage.getItem('yukyu-theme');
                    this.assertEqual(saved, newTheme, 'Debe guardar nuevo tema');

                    localStorage.removeItem('yukyu-theme');
                });

                // ========== Flujo 5: M√∫ltiples requests concurrentes ==========
                await this.test('Flujo - M√∫ltiples requests concurrentes (race condition)', async () => {
                    this.trackFlow('concurrent-requests');

                    let requestOrder = [];
                    window.fetch = async (url) => {
                        const year = url.includes('2023') ? '2023' : '2024';
                        requestOrder.push(`start-${year}`);

                        // Primera request demora m√°s
                        const delay = url.includes('2023') ? 100 : 10;
                        await new Promise(resolve => setTimeout(resolve, delay));

                        requestOrder.push(`end-${year}`);

                        return {
                            ok: true,
                            json: async () => ({
                                data: [{ employee_num: year }],
                                available_years: []
                            })
                        };
                    };

                    const state = { data: [] };
                    const ds = new DataService();

                    // Disparar dos requests
                    const p1 = ds.fetchEmployees(2023, true, state);
                    const p2 = ds.fetchEmployees(2024, true, state);

                    await Promise.all([p1, p2]);

                    // La segunda request debe ganar
                    this.assertEqual(state.data[0].employee_num, '2024',
                        'Debe usar datos de la request m√°s reciente');

                    restoreFetch();
                });

                // ========== Flujo 6: Manejo de errores en cadena ==========
                await this.test('Flujo - Manejo de errores en toda la cadena', async () => {
                    this.trackFlow('error-handling');

                    // Error de red
                    window.fetch = async () => {
                        throw new TypeError('Failed to fetch');
                    };

                    let errorCaught = false;
                    const mockToast = (type, msg) => {
                        if (type === 'error') errorCaught = true;
                    };

                    const ds = new DataService();
                    await ds.fetchEmployees(2024, true, null, null, mockToast);

                    this.assert(errorCaught, 'Error debe ser capturado y mostrado');

                    // Error de servidor
                    window.fetch = async () => ({
                        ok: false,
                        status: 500,
                        text: async () => 'Internal Server Error'
                    });

                    errorCaught = false;
                    await ds.sync(null, mockToast);

                    // sync no verifica ok, pero deber√≠a lanzar al hacer json()
                    // En realidad sync s√≠ verifica ok, entonces:
                    this.assert(errorCaught, 'Error de servidor debe ser manejado');

                    restoreFetch();
                });

                // ========== Flujo 7: Secuencia completa usuario t√≠pico ==========
                await this.test('Flujo - Secuencia completa de usuario t√≠pico', async () => {
                    this.trackFlow('typical-user');

                    // 1. Usuario carga la p√°gina
                    const tm = new ThemeManager();
                    tm.init();

                    // 2. Datos se cargan
                    mockFetch({
                        data: [
                            { employee_num: '001', name: 'Test', granted: 10, used: 3, year: 2024 },
                            { employee_num: '002', name: 'Test2', granted: 10, used: 8, year: 2024 }
                        ],
                        available_years: [2024]
                    });

                    const state = { data: [], availableYears: [] };
                    const ds = new DataService();
                    await ds.fetchEmployees(2024, true, state);

                    this.assertEqual(state.data.length, 2, 'Datos cargados');

                    // 3. Usuario filtra datos
                    const filtered = ds.getFiltered(state.data, 2024);
                    this.assertEqual(filtered.length, 2, 'Filtrado funciona');

                    // 4. Datos se procesan para visualizaci√≥n
                    const stats = ds.getFactoryStats(filtered);
                    this.assert(Array.isArray(stats), 'Stats generadas');

                    // 5. Usuario cambia tema
                    tm.toggle();
                    this.assert(tm.current === 'light' || tm.current === 'dark',
                        'Tema cambiado');

                    // 6. Los datos escapados se muestran seguros
                    const safeName = escapeHtml(state.data[0].name);
                    this.assert(typeof safeName === 'string', 'Nombres escapados');

                    restoreFetch();
                });

                // ========== Flujo 8: C√°lculo de m√©tricas en tiempo real ==========
                await this.test('Flujo - C√°lculo de m√©tricas en tiempo real', async () => {
                    const data = [
                        { granted: 10, used: 5, balance: 5 },
                        { granted: 10, used: 8, balance: 2 },
                        { granted: 10, used: 10, balance: 0 },
                        { granted: 0, used: 0, balance: 0 }
                    ];

                    // Calcular usage rate
                    const withRate = data.map(e => ({
                        ...e,
                        usageRate: e.granted > 0 ? Math.round((e.used / e.granted) * 100) : 0
                    }));

                    this.assertEqual(withRate[0].usageRate, 50, 'Rate 50% correcto');
                    this.assertEqual(withRate[1].usageRate, 80, 'Rate 80% correcto');
                    this.assertEqual(withRate[2].usageRate, 100, 'Rate 100% correcto');
                    this.assertEqual(withRate[3].usageRate, 0, 'Rate con granted=0 es 0');

                    // Categorizar por balance
                    const critical = data.filter(e => e.balance === 0).length;
                    const warning = data.filter(e => e.balance > 0 && e.balance < 3).length;

                    this.assertEqual(critical, 2, '2 empleados en cr√≠tico');
                    this.assertEqual(warning, 1, '1 empleado en warning');
                });

                restoreFetch();
            }
        }

        // Ejecutar tests
        const runner = new UIFlowTestRunner();
        runner.run();
    </script>
</body>
</html>
